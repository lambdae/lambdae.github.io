---
layout: post
title: AC自动机中NFA到DFA的转换
description:  记录Aho-Corasick自动机的转换
categories: string-match algorithm tech
author: lambdae
---


*  **引言**

    编译原理课程有介绍过NFA（非确定性状态机）到DFA（确定性状态机）的转换。直到最近才接触到相关的工程实践，还好编译原理的理论没丢光，思索片刻还能想起出处。这里简单记录下AC自动机里的转换过程。



* **简析**

    ahocorasick是建立在trie上的多模式字符串匹配算法，其本质是在trie上构造一个DFA，对于每个字符输入都有两种确定的状态: **匹配成功**、**匹配失败**。匹配过程即在这个DFA上不停的根据输入字符进行跳转，并记录途径节点的output匹配到的模式串，当消化掉所有输入字符后，根据output函数输出这些匹配到的模式串。这里不再重复叙述算法流程和相关原理，可自行查阅[维基百科](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm)以及[相关课件](https://www.cs.uku.fi/~kilpelai/BSA05/lectures/slides04.pdf)。

    回到NFA转换DFA的问题，根据以下buildFails函数，算法可以构造出一个NFA。

    ```go
    func (m *Matcher) buildFails() {
    	q := &list.List{}
    	da, ro := m.da, 0
    	m.fails[ro] = ro
    	chds := m.da.childs(ro)
    	for _, c := range chds {
    		m.fails[c.ID] = ro
    		q.PushBack(c)
    	}
    	var fid int
    	for q.Len() != 0 {
    		e := q.Front()
    		q.Remove(e)
    		nid := e.Value.(ndesc).ID
    		if da.isEnd(nid) {
    			vk, _ := da.vKeyOf(nid)
    			m.output[nid].vKey = vk
    		}
    		chds := da.childs(nid)
    		for _, c := range chds {
    			q.PushBack(c)
    			for fid = nid; fid != ro; fid = m.fails[fid] {
    				fs := m.fails[fid]
    				if da.hasLabel(fs, c.Label) {
    					fid, _ = da.child(fs, c.Label)
    					break
    				}
    			}
    			m.fails[c.ID] = fid
    		}
    	}
    }
    ```

    为了形象化这个NFA，我们假定现在输入Steel、tee、e作为模式串，The Man Of Steel: Superman作为待匹配的文本。那么通过以上的算法我们得到NFA：

    ![image](https://raw.githubusercontent.com/lambdae/lambdae.github.io/master/images/acnfa.png)

    ```c
    #include <stdio.h>
    #include <stdint.h>

    // 输出size2bin_tbl哈希表
    int main(int argc, char const *argv[])
    {
    	int n = sizeof(size2bin_tbl) / sizeof(char);
    	int last = -1, curr;
    	for (int i = 0; i < n; i++) {
    		curr = size2bin_tbl[i];
    		if (curr != last) {
    			printf("\n");
    		}
    		printf("%d ", curr);
    		last = curr;
    	}

    	return 0;
    }
    ```


*  **总结**

    综合上面的分析，我们知道，该hash的思想就是去掉size的低位(最小slab大小，SHIFT_TINY_SIZE)，取高位的掩码mask=size-1做为key查找槽位。而mask所有可能落在的区域都填充了槽位的索引。
    ​


